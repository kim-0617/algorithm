<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>덧칠하기</title>
    <link rel="stylesheet" href="asset/css/dracula.css">
    <link rel="stylesheet" href="asset/css/style.css">
</head>

<body>
    <main id="main">
        <div class="document">
            <h2 class="t_tit">1 단계 : 덧칠하기</h2>
            <p class="t_desc" class="t_desc" class="t_desc" class="t_desc">
                코딩테스트 연습 > 연습문제 > 덧칠하기
            </p>

            <hr />
            <p class="t_desc">어느 학교에 페인트가 칠해진 길이가 n미터인 벽이 있습니다. 벽에 동아리 · 학회 홍보나 회사 채용 공고 포스터 등을 게시하기 위해
                테이프로 붙였다가 철거할
                때 떼는 일이 많고 그 과정에서 페인트가 벗겨지곤 합니다. 페인트가 벗겨진 벽이 보기 흉해져 학교는 벽에 페인트를 덧칠하기로 했습니다.</p>

            <p class="t_desc">넓은 벽 전체에 페인트를 새로 칠하는 대신, 구역을 나누어 일부만 페인트를 새로 칠 함으로써 예산을 아끼려 합니다. 이를 위해 벽을 1미터 길이의 구역
                n개로
                나누고, 각 구역에 왼쪽부터 순서대로 1번부터 n번까지 번호를 붙였습니다. 그리고 페인트를 다시 칠해야 할 구역들을 정했습니다.
            </p>

            <p class="t_desc">벽에 페인트를 칠하는 롤러의 길이는 m미터이고, 롤러로 벽에 페인트를 <strong>한 번</strong> 칠하는 규칙은 다음과
                같습니다.</p>

            <ul>
                <li>롤러가 벽에서 벗어나면 안 됩니다. </li>
                <li>구역의 일부분만 포함되도록 칠하면 안 됩니다.</li>
            </ul>

            <p class="t_desc">즉, 롤러의 좌우측 끝을 구역의 경계선 혹은 벽의 좌우측 끝부분에 맞춘 후 롤러를 위아래로 움직이면서 벽을 칠합니다. 현재 페인트를 칠하는 구역들을 완전히
                칠한 후 벽에서 롤러를
                떼며, 이를 벽을 <strong>한 번</strong> 칠했다고 정의합니다.</p>

            <p class="t_desc">한 구역에 페인트를 여러 번 칠해도 되고 다시 칠해야 할 구역이 아닌 곳에 페인트를 칠해도 되지만 다시 칠하기로 정한 구역은 적어도 한 번 페인트칠을 해야
                합니다. 예산을 아끼기
                위해 다시 칠할 구역을 정했듯 마찬가지로 롤러로 페인트칠을 하는 횟수를 최소화하려고 합니다.</p>

            <p class="t_desc2">정수 n, m과 다시 페인트를 칠하기로 정한 구역들의 번호가 담긴 정수 배열
                section이 매개변수로 주어질
                때 롤러로 페인트칠해야 하는 최소 횟수를 return 하는 solution 함수를 작성해 주세요.
            </p>

            <hr>
            <i>제한사항</i>
            <ul>
                <li>1 ≤ m ≤ n ≤ 100,000</li>
                <li>1 ≤ section의 길이 ≤ n

                    <ul>
                        <li>1 ≤ section의 원소 ≤ n</li>
                        <li>section의 원소는 페인트를 다시 칠해야 하는 구역의 번호입니다.</li>
                        <li>section에서 같은 원소가 두 번 이상 나타나지 않습니다.</li>
                        <li>section의 원소는 오름차순으로 정렬되어 있습니다.</li>
                    </ul>
                </li>
            </ul>

            <hr>
            <i>입출력 예</i>
            <table class="t_table">
                <thead>
                    <tr>
                        <th>n</th>
                        <th>m</th>
                        <th>section</th>
                        <th>result</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="ce">8</td>
                        <td class="ce">4</td>
                        <td class="ce">[2, 3, 6]</td>
                        <td class="ce">2</td>
                    </tr>
                    <tr>
                        <td class="ce">5</td>
                        <td class="ce">4</td>
                        <td class="ce">[1, 3]</td>
                        <td class="ce">1</td>
                    </tr>
                    <tr>
                        <td class="ce">4</td>
                        <td class="ce">1</td>
                        <td class="ce">[1, 2, 3, 4]</td>
                        <td class="ce">4</td>
                    </tr>
                </tbody>
            </table>

            <hr>
            <i>입출력 예 설명</i>

            <p class="t_desc">입출력 예 #1</p>
            <ul>
                <li>
                    <p class="t_desc">예제 1번은 2, 3, 6번 영역에 페인트를 다시 칠해야 합니다. 롤러의 길이가 4미터이므로 한 번의 페인트칠에 연속된 4개의 구역을 칠할
                        수 있습니다. 처음에 3,
                        4, 5, 6번 영역에 페인트칠을 하면 칠해야 할 곳으로 2번 구역만 남고 1, 2, 3, 4번 구역에 페인트칠을 하면 2번 만에 다시 칠해야 할 곳에 모두
                        페인트칠을 할 수 있습니다. </p>

                    <p class="t_desc"><img
                            src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/7e657b3f-1e5b-4724-b053-9548b2cd17ba/img1.png"
                            title="" alt="img1.png"></p>

                    <p class="t_desc">2번보다 적은 횟수로 2, 3, 6번 영역에 페인트를 덧칠하는 방법은 없습니다. 따라서 최소 횟수인 2를 return 합니다.</p>
                </li>
            </ul>

            <p class="t_desc">입출력 예 #2</p>
            <ul>
                <li>
                    <p class="t_desc">예제 2번은 1, 3번 영역에 페인트를 다시 칠해야 합니다. 롤러의 길이가 3미터이므로 한 번의 페인트칠에 연속된 3개의 구역을 칠할 수
                        있고 1, 2, 3번 영역에
                        페인트칠을 하면 한 번에 1, 3번 영역을 모두 칠할 수 있습니다. </p>

                    <p class="t_desc"><img
                            src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/fb5be7bd-e792-4317-9868-f11e7aaf6f03/img2.png"
                            title="" alt="img2.png"></p>

                    <p class="t_desc">따라서 최소 횟수인 1을 return 합니다.</p>
                </li>
            </ul>

            <p class="t_desc">입출력 예 #3</p>

            <ul>
                <li>
                    <p class="t_desc">예제 3번은 모든 구역에 페인트칠을 해야 합니다. 롤러의 길이가 1미터이므로 한 번에 한 구역밖에 칠할 수 없습니다. 구역이 4개이므로 각
                        구역을 한 번씩만 칠하는
                        4번이 최소 횟수가 됩니다.</p>

                    <p class="t_desc"><img
                            src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/dddf1413-d81a-4199-a8e3-f10f58c59fcc/img3.png"
                            title="" alt="img3.png"></p>

                    <p class="t_desc">따라서 4를 return 합니다.</p>
                </li>
            </ul>

            <hr />
            <h3 class="t_tit2">코드</h3>
            <div class="t_code">
                <pre><code class="language-js">function solution(n, m, section) {
    let answer = 0;
    const target = Array.from({length : n}, (x,i) => i + 1);
    // 1번예시를 들면 1 ~ 8까지의 배열을 만들어줍니다.
    
    // 배열이 빌 때 까지
    while(target.length) {
        // 배열의 앞 원소가 section에 있으면 페인트 칠을 쭉 합니다.
        // 페인트칠을 한다는 것은 없앤다는 겁니다.
        if(section.includes(target[0])) {
            target.splice(0, m);
            answer++; // 페인트 칠을 할 때 마다 +1
        } else { // 페인트 구역이 아니면 삭제하고 넘깁니다.
            target.shift();
        }
    }
    
    return answer;
}
</code></pre>
            </div>

            <h3 class="t_tit">리뷰</h3>
            <p class="t_desc" class="t_desc" class="t_desc" class="t_desc">
                1. 우선 구역을 만들어줍니다. 구역 n이라면 1~n까지의 구역을 배열로 만듭니다.<br>
                2. 이 구역배열이 빌때까지 while문을 돌건데 칠할필요가 없는 구역은 shift로 삭제해버립니다.<br>
                3. 칠할구역을 만나면 롤러의 크기만큼 싹 삭제해버립니다. 그리고 칠했으니까 answer++ 해주고<br>
                4. 최종적으로 배열의 원소를 모두 삭제하고 while문을 탈출했을때 answer을 return 해줍니다.<br>
                총평 :천천히 생각해보면 무난하게 풀 수 있는 문제였습니다. <br>
            </p>
            출처 :
            <a
                href="https://school.programmers.co.kr/learn/courses/30/lessons/161989">https://school.programmers.co.kr/learn/courses/30/lessons/161989</a>
            </p>
        </div>
    </main>

    <script src="asset/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>

</html>